<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="">
  <meta name="keyword" content="hexo-theme">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      LeetCode 中等题汇总（20210412 更新/73） | Daily Growing
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 7.0.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Daily Growing</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>LeetCode 中等题汇总（20210412 更新/73）</h2>
  <p class="post-date">2019-08-27</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>Medium思考题，分类&#x2F;题意&#x2F;思路&#x2F;代码。</p>
<span id="more"></span>
<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80 Remove Duplicates from Sorted Array II"></a>80 Remove Duplicates from Sorted Array II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/submissions/">Remove Duplicates from Sorted Array II</a></p>
<p>给出一组排好序的数，要求去除数组里数，使其中数最多重复两次。返回数组长度。</p>
<table>
<thead>
<tr>
<th align="center">Given</th>
<th align="center">Modified</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[1,1,1,2,2,3]</td>
<td align="center">[1,1,2,2,3]</td>
</tr>
<tr>
<td align="center">[0,0,1,1,1,1,2,3,3]</td>
<td align="center">[0,0,1,1,2,3,3]</td>
</tr>
<tr>
<td align="center">[0,0,0,0,0]</td>
<td align="center">[0,0]</td>
</tr>
</tbody></table>
<hr>
<p>说是medium但其实也很水，保持两个数组概念，和#26 #27类似，设定变量，判定当前数组当前位和新数组前两位是否相同，不同则存入。覆盖原数组。</p>
<p>2019.05.16</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[flag - <span class="number">2</span>]) &#123;<span class="comment">//关键步骤</span></span><br><span class="line">                nums[flag++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134 Gas Station"></a>134 Gas Station</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/gas-station/">Gas Station</a></p>
<p>给出两组数，第一组gas分别表示每个加油站可加的油，第二组cost分别表示目前加油站到达下一加油站所消耗的油量。要求从某一加油站加满油出发，顺时针循环所有的加油站并回到出发的加油站，返回该出发加油站的索引。如果中途油不够无法完成循环，则返回-1。</p>
<p>2019.05.18</p>
<ul>
<li>解一</li>
</ul>
<p>指定了是顺时针循环的话，难度就降低了很多。先预设结果是不可能，station &#x3D; -1。遍历每一站，对每一站尝试进行“加油、消耗”操作，如果结果为负，说明在前往下一站的路上油不足，跳出循环看下一站，如果结果为正说明走得通。数组循环的话并不难，将其前面的位数都排到后面来即可，例如：</p>
<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">gas</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">cost</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>从index为3（即第四个）加油站出发的话，循环到回到原处就是将两组的前三位复制到末尾。可构思存在这样一个数组：</p>
<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">gas</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">cost</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>但因为是重复的，所以也不必再设立一个数组增加空间复杂度，只需要简单进行求余算index获得数值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">station</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++)&#123;<span class="comment">//遍历每一站</span></span><br><span class="line">            <span class="keyword">while</span>(gas[i] &lt; cost[i] &amp;&amp; i &lt; gas.length-<span class="number">1</span>) i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; gas.length + i; j++)&#123;<span class="comment">//对每一站作预判</span></span><br><span class="line">                sum += gas[j%gas.length]-cost[j%gas.length];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)station = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> station;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二</li>
</ul>
<p>-1的判断其实是很容易的，只要所有加油站油总量比要消耗的要少，就是无法完成循环操作，返回-1。除此以外的情况是一定有满足条件的出发加油站。</p>
<p>既然确定答案肯定存在，就可以大胆预设。由解一可以看到，这样的一个加油站将这个循环路程分为两段，前一段路程一旦出现亏损，即run &lt; 0，说明肯定无法抵达下一站，但是既然预设这样一个出发站肯定存在，那么说明亏损之后肯定存在盈余，才能支撑整个循环油量的收支平衡。这里很容易想到，一段循环路程，如果要出现亏损，势必也是先盈余后亏损。因此，出现亏损的点十分重要，预示着之前的路程应该属于循环路途的末尾段，而该点之后的路程应该属于起先段，所以将该点之后的第一个加油站设为起发站。</p>
<p>但如何能确定这就是唯一的起发站呢？还有一点需要注意，假设了一个起发站后，如果以起发站为界，加了该起发点的油后，如果之后的路程还出现油量亏损到无法去下一站的情况，那么该假设的加油站需要舍弃，无法到达的下一站一定有充足的油量能够驶完全程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run += (gas[i] - cost[i]);</span><br><span class="line">    <span class="keyword">if</span> (run &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        start = i + <span class="number">1</span>;</span><br><span class="line">        run = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一步真的很巧妙，包含了“测试每一个起发点，如果无法去下一个站点即舍弃”的操作。同时还包含了一个解题关键：在确定能完成循环的前提下，目前的路程一旦出现无法去下一站的情况，则下一站一定是起发点，同时重新计算路程油量的收支情况，不行则再次舍弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>, run = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; ++i)&#123;</span><br><span class="line">            run += (gas[i] - cost[i]);</span><br><span class="line">            rest += (gas[i] - cost[i]);</span><br><span class="line">            <span class="keyword">if</span> (run &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                run = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rest &lt; <span class="number">0</span> ? -<span class="number">1</span>: start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="229-Majority-Element-II"><a href="#229-Majority-Element-II" class="headerlink" title="229 Majority Element II"></a>229 Majority Element II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element-ii/">Majority Element II</a></p>
<p>给出两组无序数，返回所有占总数三分之一以上的数</p>
<p>2019.05.19</p>
<ul>
<li>解一</li>
</ul>
<p>蠢办法，先快排一下，遍历数组中每一位，直接跨越数组三分之一的长度和目标数比较，如果相同则再看之前有没有收入相同的该数，没有则收入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; nums.length-nums.length/<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+nums.length/<span class="number">3</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(answer.isEmpty())&#123;</span><br><span class="line">                    answer.add(nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(answer.get(answer.size()-<span class="number">1</span>) != nums[i])&#123;</span><br><span class="line">                    answer.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> hight)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, j, index;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        index = a[i]; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123; </span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= index)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                a[i++] = a[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = index;</span><br><span class="line">        quickSort(a, low, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, i + <span class="number">1</span>, hight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二</li>
</ul>
<p>摩尔投票算法，相同的三个数可以消除，判断留下的最终两位是否符合存在大于三分之一的条件。算法介绍可参见这篇文章：<a target="_blank" rel="noopener" href="https://zansy.github.io/2019/05/18/BoyerMooreVotingAlgorithm/">Boyer-Moore Voting Algorithm 摩尔投票算法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate1</span> <span class="operator">=</span> <span class="number">0</span>,candidate2 = <span class="number">0</span>,count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 = count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length/<span class="number">3</span>) answer.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length/<span class="number">3</span>) answer.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274 H-Index"></a>274 H-Index</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/h-index/">H-Index</a></p>
<p>涉及一个<code>h-index</code>的概念</p>
<blockquote>
<p>H指数的计算基于其研究者的论文数量及其论文被引用的次数。赫希认为：一个人在其所有学术文章中有N篇论文分别被引用了至少N次，他的H指数就是N。如美国耶鲁大学免疫学家理查德·弗来沃发表的900篇文章中，有107篇被引用了107次以上，他的H指数是107。</p>
</blockquote>
<p>给出一组长度为n的无序数，表示该科学家的n篇论文对应的被引次数，求该科学家的H指数</p>
<p>2019.05.20</p>
<ul>
<li>解一</li>
</ul>
<p>很容易想到从高到底快排一次，遍历该降序数组，如果当前值大于等于其序号（从1开始而非0开始）就存入，不停覆盖。例如例题中[3,0,6,1,5]排序后[6,5,3,1,0]，第<code>1</code>篇引用次数<code>6</code>大于等于<code>1</code>，第<code>2</code>篇引用次数<code>5</code>大于等于<code>2</code>，第<code>3</code>篇引用次数<code>3</code>大于等于<code>3</code>，覆盖存入，之后的都不会进入if语句块。最后得到最终结果为3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        quickSort(citations,<span class="number">0</span>,citations.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; citations.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(citations[i] &gt;= i+<span class="number">1</span>)&#123;</span><br><span class="line">                answer = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, starter;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)<span class="keyword">return</span>;</span><br><span class="line">        starter = nums[left];</span><br><span class="line">        i = left;</span><br><span class="line">        j = right;</span><br><span class="line">        <span class="keyword">while</span> (i != j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt;= starter &amp;&amp; i &lt; j)j--;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= starter &amp;&amp; i &lt; j)i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[i];</span><br><span class="line">        nums[i] = starter;</span><br><span class="line"></span><br><span class="line">        quickSort(nums, left, i-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二 桶排序</li>
</ul>
<p>首先想到的也是排序，桶排序的话长度是多少呢？破除常规思路，想到总共n篇文章，H指数最大为n，最小为0，设置桶排序的序号为答案，序号最长也不过是n，由此设立一个序号为0-n的数组。例如对[4,0,6,1,5]进行桶排序：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>注意这里，大于n的6也被归类于序号为n的计数中，因为大于n的不管多少都不必在意其值了。然后将这个数组从后向前遍历，本质上模拟一个将原引用数组从高到低排序再数数的过程：前2篇文章不大于其序号5，前3篇文章不大于其序号4，类似于对答案再往下对一步：前3篇文章大于等于其序号，则返回当前序号3。<br>注意这里需要考虑[1,1]等类似情况，因此if语句中不能是count &#x3D;&#x3D; i。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[citations.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c : citations) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= citations.length) &#123;</span><br><span class="line">                buckets[citations.length]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buckets[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> citations.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            count += buckets[i];</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="275-H-Index-II"><a href="#275-H-Index-II" class="headerlink" title="275 H-Index II"></a>275 H-Index II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/h-index/">H-Index II</a></p>
<p>题意如#274，但这次给出的是升序数组，要求时间复杂度对数级。</p>
<hr>
<p>既然是对数级，就用二分查找。<br>举例[0,1,4,5,6]，数组中每个值和它的h值有这样的对应关系：</p>
<table>
<thead>
<tr>
<th align="center">数组值</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">需要对应的h值</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>在二分查找的过程中，如果某个h值满足条件（即h值小于它对应的值），我们就到前半部分继续查找；如果h值不满足条件（即h值大于它对应的值），我们就到前半部分继续查找。</p>
<p>2019.05.20</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = citations.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( citations[mid] &lt; citations.length-mid) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> citations.length-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220 Contains Duplicate III"></a>220 Contains Duplicate III</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate-iii/">Contains Duplicate III</a></p>
<p>给出一组无序数nums，一个k，一个t，要求存在nums[i]和nums[j]，使得二者绝对值小于等于t，同时i与j的绝对值小于等于k。</p>
<hr>
<p>思路如219，设置一个长度为k+1的窗口，例如[1,5,9,1,5,9]，k&#x3D;2，t&#x3D;3时，则需要设置一个长度为3的窗口，在窗口中观察是否有这样的两个数字满足绝对值小于等于t的情况。不满足则窗口往后平移一位。159，591，915，159，这样平移。</p>
<p>但是窗口中的数字要怎样方便快捷地判断其绝对值呢？想办法排序，但是桶排的话需要的空间太大了，要怎么样尽可能地压缩空间呢？压缩空间，就是减小排序后差值最小的两个数的距离。这里的思路是把当前数除以t，例如[1,5,9,1,5,9]，除以t &#x3D; 3得到的号码牌就是[0,1,3,0,1,3]，可见1和5之间的距离被压缩了。</p>
<p>但是尽管相邻，也不代表1和5之间满足绝对值小于等于3的条件，这个时候仍需要参考原数值的值，因此在判断条件后，要将当前数值的号码牌和值本身一起存入一个长度为k的HashMap中。</p>
<p>但这一题小陷阱很多，t是绝对值，肯定不能小于0。那么为了制作号码牌的时候设置除以t+1；数组中存在负数，那么每次先减去一个设定的最小值，即加上一个最大值。</p>
<p>2019.05.21</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyAlmostDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Long&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferedCurrentNum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] - Integer.MIN_VALUE;<span class="comment">//解决负数问题</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">bucketId</span> <span class="operator">=</span> transferedCurrentNum / ((<span class="type">long</span>)t + <span class="number">1</span>);<span class="comment">//本意是该/t，但考虑到t为0的情况，选择除以t+1</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(bucketId) ||</span><br><span class="line">                    map.containsKey(bucketId - <span class="number">1</span>) &amp;&amp; transferedCurrentNum - map.get(bucketId - <span class="number">1</span>) &lt;= t ||</span><br><span class="line">                    map.containsKey(bucketId + <span class="number">1</span>) &amp;&amp; map.get(bucketId + <span class="number">1</span>) - transferedCurrentNum &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.entrySet().size() &gt;= k)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastBucket</span> <span class="operator">=</span> ((<span class="type">long</span>) nums[i-k] - Integer.MIN_VALUE) / (t + <span class="number">1</span>);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucketId, transferedCurrentNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55 Jump Game"></a>55 Jump Game</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">Jump Game</a></p>
<p>给出一组无序的非负整数，每个数字是指在其索引的位置上能往右走的最大步数，问在第一位是否能走到数组最后一位。</p>
<hr>
<p>具体解法看这一篇博文：<a target="_blank" rel="noopener" href="https://zansy.github.io/2019/05/24/LeetCode-55-DP/">从 LeetCode#55 入门动态规划</a></p>
<p>2019.05.22</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastCanJumpToTheEnd</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastCanJumpToTheEnd - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + nums[i] &gt;= lastCanJumpToTheEnd) lastCanJumpToTheEnd = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastCanJumpToTheEnd == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309 Best Time to Buy and Sell Stock with Cooldown"></a>309 Best Time to Buy and Sell Stock with Cooldown</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p>给出一组无序数prices，表示商品在不同日期（索引）时对应的不同价格。可以进行无限次交易，但每次只能保持一次完整的交易，即买入新的前必须卖出旧的。并且每次交易后的第二天不能交易</p>
<hr>
<p>动态规划好难啊…</p>
<p>2019.06.01</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sold</span> <span class="operator">=</span> <span class="number">0</span>, hold = -prices[<span class="number">0</span>], rest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prvSold</span> <span class="operator">=</span> sold;</span><br><span class="line">            sold = hold + prices[i];<span class="comment">//假设卖出当前股票后的余额</span></span><br><span class="line">            </span><br><span class="line">            hold = Math.max(hold, rest-prices[i]);<span class="comment">//当前持有或是买入</span></span><br><span class="line">            rest = Math.max(rest, prvSold);<span class="comment">//rest 特殊性，因此得比较前一天卖出的余额</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sold, rest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11 Container With Most Water"></a>11 Container With Most Water</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a></p>
<p>给出一组无序数height，表示在x轴上不同高度的线。两线可组成容器盛水，底是两线之间的距离，高是较短的一线，求能盛最多水的容器的长宽积。</p>
<p>2019.06.04</p>
<ul>
<li>解一</li>
</ul>
<p>暴力进行一位一位比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; height.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j - i)* Math.min(height[i],height[j]) &gt; maxArea)</span><br><span class="line">                    maxArea = (j - i)* Math.min(height[i],height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二</li>
</ul>
<p>思路不算难，先从距离最远的两端开始，两端中选出最长的保留，另一端缩短距离再比较，重复操作，直到间距最小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> Math.min(height[left] , height[right]) * (right);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &gt; height[right])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[left] , height[right]) * (right - left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15 3Sum"></a>15 3Sum</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/">3Sum</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h2 id="示例-1：示例-2：示例-3："><a href="#示例-1：示例-2：示例-3：" class="headerlink" title="示例 1：示例 2：示例 3："></a>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></h2><p>先将数组进行排序，遍历每一位，获得其对应数字，接下去的任务就是从之后的数组中查找出是否有两数之和等于该对应数字。<br>这一阶段任务可以应用部分二分法，从两端找起，如果两端之和比该数大，则右边向内进一位，否则左边向内进一位。<br>注意重复值。在最开始就消除重复值的计算，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>2021.02.03</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length -<span class="number">1</span>, sum = -nums[i];</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[left] + nums[right] == sum)&#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])right--;</span><br><span class="line">                        left++; right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; sum) left++;</span><br><span class="line">                    <span class="keyword">else</span> right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16 3Sum Closest"></a>16 3Sum Closest</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">3Sum Closest</a></p>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) </span><br></pre></td></tr></table></figure></h2><p>和第15题的思路差不多。</p>
<blockquote>
<p>先将数组进行排序，遍历每一位，获得其对应数字，接下去的任务就是从之后的数组中查找出是否有两数之和等于该对应数字。<br>这一阶段任务可以应用部分二分法，从两端找起，如果两端之和比该数大，则右边向内进一位，否则左边向内进一位。</p>
</blockquote>
<p>但其中有一点不同，将每次获得的值设为tempSum，去和上一次选出的最接近值比较，如果比其更接近target则替换。</p>
<p>2021.02.05</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//-3 0 1 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastOne</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempSum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(tempSum - target) &lt; Math.abs(lastOne - target)) lastOne = tempSum;</span><br><span class="line">                    <span class="keyword">if</span> (tempSum == target) <span class="keyword">return</span> target;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (tempSum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18 4Sum"></a>18 4Sum</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum/">4Sum</a></p>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<h2 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></h2><p>和第15题的思路差不多。</p>
<blockquote>
<p>先将数组进行排序，遍历每一位，获得其对应数字，接下去的任务就是从之后的数组中查找出是否有两数之和等于该对应数字。<br>这一阶段任务可以应用部分二分法，从两端找起，如果两端之和比该数大，则右边向内进一位，否则左边向内进一位。</p>
</blockquote>
<p>和第15题的区别无非是外面再套一层罢了<br>但这样的解法时间和空间复杂度都很高。<br>除此以外，还可以进行一些细微的优化工作，例如在第一层循环中：</p>
<ol>
<li>确定最左边的1个数，剩下3个数选择数组其余最小3个数，四个数字之和如果大于target，则可以直接退出循环</li>
<li>确定最左边的1个数，剩下3个数选择排序后数组最大三个数，四个数的和如果小于target则可以不必进入第二层循环，继续换第一个数。</li>
</ol>
<p>同时在第二层循环中同样也可以细节优化：</p>
<ol>
<li>确定前两个数后，后两位选择数组中最大数字，如果小于target则退出</li>
<li>确定前两个数后，后两位选择数组中最小数字，如果大于target则退出</li>
</ol>
<p>2021.02.05</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//-3 0 1 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastOne</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempSum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(tempSum - target) &lt; Math.abs(lastOne - target)) lastOne = tempSum;</span><br><span class="line">                    <span class="keyword">if</span> (tempSum == target) <span class="keyword">return</span> target;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (tempSum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细节优化后：</p>
<blockquote>
<p>Runtime: 4 ms, faster than 96.51% of Java online submissions for 4Sum.<br>Memory Usage: 39.2 MB, less than 93.04% of Java online submissions for 4Sum.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[nums.length - <span class="number">1</span>] + nums[nums.length - <span class="number">2</span>] + nums[nums.length - <span class="number">3</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[nums.length - <span class="number">2</span>] + nums[nums.length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[left], nums[right]);</span><br><span class="line">                        <span class="keyword">if</span> (!result.contains(temp)) result.add(temp);</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56 Merge Intervals"></a>56 Merge Intervals</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a></p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<hr>
<p>这题用了Java 8 里的lambda comparator，先把数组排序，然后添加排序后的第一个数组。再将之后数组的起始端和第一个数组的结尾端比较。如果在第一个数组表示的间隙内，再判断两个间隙哪个结尾更长；否则的话表示第一个间隔已经没有可以进行扩展的了，添加新间隔为新加入的数组。</p>
<p>注意原来ArrayList中添加过的数组数值在List之外修改 还是会影响List中的结果。</p>
<p>2021.02.09</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, (i1, i2) -&gt; Integer.compare(i1[<span class="number">0</span>], i2[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span>[] newInterval = intervals[<span class="number">0</span>];</span><br><span class="line">        result.add(newInterval);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], temp[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval = temp;</span><br><span class="line">                result.add(newInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57 Insert Interval"></a>57 Insert Interval</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-interval/">Insert Interval</a></p>
<p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [], newInterval = [5,7]</span><br><span class="line">输出：[[5,7]]</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,3]</span><br><span class="line">输出：[[1,5]]</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,7]</span><br><span class="line">输出：[[1,7]]</span><br></pre></td></tr></table></figure>

<hr>
<p>设立一个start end来标识当前正在考虑插入的间隔。同时遍历给定间隔的数组。将考虑的间隔与给定的间隔比较。这里又分为3种情况：</p>
<ol>
<li>两者不重复，且考虑间隔在给定间隔右侧。此时直接将给定间隔存入即可。</li>
<li>两者不重复，且考虑间隔在给定间隔左侧。此时先加入考虑间隔。再将当前给定间隔列为新的考虑间隔。</li>
<li>两者重复。则考虑间隔进行更新扩大范围，但不存入，仍需进行下一次考虑。</li>
</ol>
<p>在循环结束后，存入最后手中的考虑间隔。</p>
<p>2021.02.10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> newInterval[<span class="number">0</span>], end = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; start)&#123;</span><br><span class="line">                result.add(interval);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; end)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = interval[<span class="number">0</span>];</span><br><span class="line">                end = interval[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = Math.min(start, interval[<span class="number">0</span>]);</span><br><span class="line">                end = Math.max(end, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75 Sort Colors"></a>75 Sort Colors</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/">Sort Colors</a></p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
 </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<hr>
<p>其实就是给出一组全是0，1，2的数组，要求进行从小到大排序。<br>这题的特别处是在原数组下进行数字的变换。因此设立了一个可移动的start点&amp;end点进行推进和整理。<br>首先对数组中每一位进行处理，如果等于2就和end点上的数据进行交换，再处理一遍交换来的数字；等于0则和start点上的数据进行交换，处理下一位。</p>
<p>2021.02.21</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= end;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, i, end);</span><br><span class="line">                end--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, start);</span><br><span class="line">                start++;i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334 Increasing Triplet Subsequence"></a>334 Increasing Triplet Subsequence</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-triplet-subsequence/">Increasing Triplet Subsequence</a></p>
<p>给出一组无序数nums，问其中是否存在三个数，nums[i] &lt; nums[j] &lt; nums[k],同时i &lt; j &lt; k。要求时间复杂度O(n)，空间复杂度O(1)。</p>
<hr>
<p>把整个数组的数分成三个层次，其中两个分界点，一层小于等于small，一层大于small但是小于等于medium，一层大于medium。small、medium没有固定的值，只要能起到分隔作用即可。一旦出现第三个数，返回true。</p>
<p>2019.06.05</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> Integer.MAX_VALUE, medium = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= small) small = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt;= medium) medium = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287 Find the Duplicate Number"></a>287 Find the Duplicate Number</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-duplicate-number/">Find the Duplicate Number</a></p>
<p>给出n+1个无序数，数组中值为1-n，找出重复的数字（必存在也只存在一个）。</p>
<p>约束如下：</p>
<ol>
<li>不能改变原数组</li>
<li>空间复杂度O(1) </li>
<li>时间复杂度最多O(n<sup>2</sup>)</li>
<li>重复数字可能不止重复一次</li>
</ol>
<p>2019.06.07</p>
<ul>
<li>解一</li>
</ul>
<p><font color = 'green'>找出无序数组重复数字，最先想到的是Arrays.sort和HashSet。</font></p>
<p>这里有约束，那就先蠢办法遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">duplicate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> duplicate; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二</li>
</ul>
<p>用到的是龟兔赛跑算法，具体解法看这里：<a target="_blank" rel="noopener" href="https://zansy.github.io/2019/06/07/Floyd-Cycle-Detection-Algorithm/">Floyd Cycle Detection Algorithm</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">tortoise</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">hare</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            tortoise = nums[tortoise];<span class="comment">//每次走一步</span></span><br><span class="line">            hare = nums[nums[hare]];<span class="comment">//每次走两步</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (tortoise != hare);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the &quot;entrance&quot; to the cycle.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finder</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (finder != tortoise) &#123;</span><br><span class="line">            finder = nums[finder];</span><br><span class="line">            tortoise = nums[tortoise];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3 Longest Substring Without Repeating Characters"></a>3 Longest Substring Without Repeating Characters</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>2021.03.23</p>
<hr>
<p>这题解法有很多，这边主要用窗口法。</p>
<ul>
<li>解一 把它想成窗口在移动</li>
</ul>
<p><img src="http://windliang.oss-cn-beijing.aliyuncs.com/slide.jpg"></p>
<p>以left和right界定窗口的边界，当left和right都没有走到最后一位的时候，不停扩张right的边界，如果发现right即将进入的那个字母是窗口中已存在的，则需要缩短左边界left直到其为已存在的字母的下一位。这时候可以以不停地缩短左边界达成这一结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, windowsMaxLength = right - left;</span><br><span class="line">        HashSet&lt;Character&gt; window = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; s.length() &amp;&amp; right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!window.contains(s.charAt(right)))&#123;</span><br><span class="line">                window.add(s.charAt(right)); right++;</span><br><span class="line">                windowsMaxLength = Math.max(windowsMaxLength, right - left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                window.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windowsMaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二 动态规划<br>剑指offer中给出了公式，首先第一位肯定可以包含其中。给一个数组f保存每一位为结尾的最长子串长度，因此f[0] &#x3D; 1。之后每一位遍历以获得数组f的内容。1.如果当前位i在之前重复过，那就算出相同的上一位的位置，算出它们的距离distance。这时候出现两种可能，一种是距离小于等于前一位s[i - 1]为结尾的最长子串长度f[i - 1]，即重复的上一位存在于当前位为结尾的最长子串中，那么f[i] &#x3D; distance；另一种是距离大于前一位s[i - 1]为结尾的最长子串长度，例如“affbcda”，进行到最后一位a的时候，前一位的最小子串是fbcd，f[5] &#x3D; 4，但是dis &#x3D; 6 &gt; 4，说明两个a之间存在重复元素导致第五位的d结尾的最长子串没有纳入重复元素，因此这种情况下f[i] &#x3D; f[i] + 1。2.如果当前位i在之前没有重复过，子串长度简单+1即可，即f[i] &#x3D; f[i] + 1。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; letterAndLastPosition = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        letterAndLastPosition.put(s.charAt(<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!letterAndLastPosition.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - letterAndLastPosition.get(s.charAt(i)) &lt;= f[i - <span class="number">1</span>])</span><br><span class="line">                    f[i] = i - letterAndLastPosition.get(s.charAt(i));</span><br><span class="line">                <span class="keyword">else</span> f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            letterAndLastPosition.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(f[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151 Reverse Words in a String"></a>151 Reverse Words in a String</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string/">Reverse Words in a String</a></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<hr>
<p>先剪枝，再用正则替换掉多余的空格，最后split切割。时空复杂度都有点高，去看了一下高票的解答代码<a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string/discuss/47720/Clean-Java-two-pointers-solution-(no-trim(-)-no-split(-)-no-StringBuilder)">Clean Java two-pointers solution (no trim( ), no split( ), no StringBuilder)
</a>，用while降低复杂度，先反转整个字符串，再分别反转单词，最后清除开头和中间多余的空格，感觉思路还挺独特的。</p>
<p>2019.06.11</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sTrim</span> <span class="operator">=</span> s.trim(); <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        sTrim = sTrim.replaceAll(<span class="string">&quot; +&quot;</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] words = sTrim.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            result += words[i] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result += words[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49 Group Anagrams"></a>49 Group Anagrams</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/group-anagrams/">Group Anagrams</a></p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<hr>
<p>思路和242差不多，但这里把排序好后的字符组设为HashMap的键，值为List。如果HashMap中没有见过这个字符串排列好后的字符组，就新建一个ArrayList，然后新增入当前字符串。</p>
<p>最后将HashMap的值返回即可。</p>
<p>还有一种办法，直接以26个字母出现次数数组 组成一个string作为键。具体可以看官方题解：<a target="_blank" rel="noopener" href="https://leetcode.com/articles/group-anagrams/">49. Group Anagrams</a></p>
<p>2019.06.13</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; sortBychars = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] strArray = str.toCharArray();</span><br><span class="line">            Arrays.sort(strArray);</span><br><span class="line">            <span class="keyword">if</span> (!sortBychars.containsKey(String.valueOf(strArray)))</span><br><span class="line">                sortBychars.put(String.valueOf(strArray), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            sortBychars.get(String.valueOf(strArray)).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sortBychars.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179 Largest Number"></a>179 Largest Number</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number/">Largest Number</a></p>
<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<blockquote>
<p>Input: [3,30,34,5,9]<br>Output: “9534330”</p>
</blockquote>
<hr>
<p>首先要把输入的整数{3,30,34,5,9}换成字符串，然后首位数字大的排在前面。例如5应该排在34的前面。但这要怎么排呢？这里有一个很巧妙的办法，当5和34进行比较的时候，实质上比较的是534和345，双方各把对方加入末尾，保证位数相同，只比较了高位。</p>
<p>这个方法可以通过重写comparator interface 里面的compare方法实现，然后使用method Arrays.sort(array[], new Comparator<String>());</p>
<p>sort完了就是降序排列。</p>
<p>2019.06.14</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//Get input intergers as strings</span></span><br><span class="line">        String[] asStrs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            asStrs[i] = String.valueOf(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Sort strings according to custom comparator</span></span><br><span class="line">        Arrays.sort(asStrs, <span class="keyword">new</span> <span class="title class_">LargerNumberComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If after being sorted, the largest number is `0`, the entire number is zero.</span></span><br><span class="line">        <span class="keyword">if</span> (asStrs[<span class="number">0</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build largest number from sorted array.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">largestNumberStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (String numAsStr : asStrs) &#123;</span><br><span class="line">            largestNumberStr += numAsStr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> largestNumberStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LargerNumberComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">order1</span> <span class="operator">=</span> a + b;</span><br><span class="line">            <span class="type">String</span> <span class="variable">order2</span> <span class="operator">=</span> b + a;</span><br><span class="line">            <span class="keyword">return</span> order2.compareTo(order1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6 ZigZag Conversion"></a>6 ZigZag Conversion</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/zigzag-conversion/">ZigZag Conversion</a></p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<hr>
<p>思路大概就是根据给定的行数，为每一行内容设立一个字符串组，比如说题目中行数为3，就设立3个字符串组。第一步先将字符串组初始化。然后读取原给定字符串的每一个字符，分别读入到3个字符串组中，最开始逐行下移，则行数++，读完一整列后逐行上升，则行数–，最后把这三行内容直接拼接整合起来就可以了。</p>
<p>还有一种思路是根据数学规律：</p>
<ul>
<li>Characters in row 0 are located at indexes k(2⋅numRows−2)</li>
<li>Characters in row numRows−1 are located at indexes k(2⋅numRows−2)+numRows−1</li>
<li>Characters in inner row i are located at indexes k(2⋅numRows−2)+i and (<em>k</em>+1)(2⋅numRows−2)−i.</li>
</ul>
<p>2019.06.15</p>
<ul>
<li>解一<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">            rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">goingDown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            rows.get(curRow).append(c);</span><br><span class="line">            <span class="keyword">if</span>(curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>)</span><br><span class="line">                goingDown = !goingDown;</span><br><span class="line">            curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder row : rows)ret.append(row);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是官方题解里给出来的代码，思路不变，修改了一下，使可读性更高<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span> || numRows &gt;= s.length()) <span class="keyword">return</span> s;</span><br><span class="line">        String[] rows = <span class="keyword">new</span> <span class="title class_">String</span>[numRows];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            rows[i] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>, direction = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            rows[curRow] += c;</span><br><span class="line">            <span class="keyword">if</span>(curRow == <span class="number">0</span>)direction = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (curRow == numRows - <span class="number">1</span>) direction = -<span class="number">1</span>;</span><br><span class="line">            curRow += direction;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String row : rows) result += row;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12 Integer to Roman"></a>12 Integer to Roman</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-to-roman/">Integer to Roman</a></p>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>2019.06.19</p>
<ul>
<li>解一</li>
</ul>
<p>仍然是用的HashMap，从最后一位开始向前遍历，每位看一下是不是在特殊情况中存在，不存在的话就再分情况获得当前位数上的结果。</p>
<p>通过insert把每位的结果添加到最终结果中。</p>
<p>这个办法的代码实在是太难看了…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line">        map.put(<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>);</span><br><span class="line">        map.put(<span class="number">50</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">        map.put(<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>);</span><br><span class="line">        map.put(<span class="number">100</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        map.put(<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>);</span><br><span class="line">        map.put(<span class="number">500</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        map.put(<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>);</span><br><span class="line">        map.put(<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">digits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey((<span class="type">int</span>)(Math.pow(<span class="number">10</span>, digits) * current)))&#123;</span><br><span class="line">                result.insert(<span class="number">0</span>, map.get((<span class="type">int</span>)(Math.pow(<span class="number">10</span>, digits) * current)));</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(current &gt; <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> map.get((<span class="type">int</span>)(Math.pow(<span class="number">10</span>, digits) * <span class="number">5</span>));</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; current - <span class="number">5</span>; i++)&#123;</span><br><span class="line">                        temp += map.get((<span class="type">int</span>)(Math.pow(<span class="number">10</span>, digits) * <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.insert(<span class="number">0</span>, temp);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; current; i++)&#123;</span><br><span class="line">                        temp += map.get((<span class="type">int</span>)(Math.pow(<span class="number">10</span>, digits) * <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.insert(<span class="number">0</span>, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            digits++;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二</li>
</ul>
<p>设立两个对应的数组，遍历特殊情况values数组，给定的不断减去当前遍历到的数字，同时输出对应的字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;values.length;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= values[i]) &#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                sb.append(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学-Math"><a href="#数学-Math" class="headerlink" title="数学 Math"></a>数学 Math</h2><h3 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h3><h4 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165 Compare Version Numbers"></a>165 Compare Version Numbers</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/compare-version-numbers/">Compare Version Numbers</a></p>
<p>两个字符串，比较版本号，前者比后者新返回1，否则返回-1。当相等时返回0。注意1.0和1比较，1.001和1.01比较的情况。</p>
<hr>
<p>思路很简单，字符串以正则拆分，对每一位数字进行二者比较，位数不足的以0补足。比较到不同的时候返回结果，相同的话跳出循环返回0。</p>
<p>2019.05.28</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        String[] version1Number = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] version2Number = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">longestLength</span> <span class="operator">=</span> Math.max(version1Number.length,version2Number.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; longestLength; i++)&#123;</span><br><span class="line">            Integer tempV1, tempV2;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; version1Number.length)</span><br><span class="line">                tempV1 = Integer.parseInt(version1Number[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tempV1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; version2Number.length)</span><br><span class="line">                tempV2 = Integer.parseInt(version2Number[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tempV2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">singleNumberCompare</span> <span class="operator">=</span>  tempV1.compareTo(tempV2);</span><br><span class="line">            <span class="keyword">if</span>(singleNumberCompare != <span class="number">0</span>) <span class="keyword">return</span> singleNumberCompare;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8 String to Integer (atoi)"></a>8 String to Integer (atoi)</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-to-integer-atoi/">String to Integer (atoi)</a></p>
<p>实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。如果数值超过这个范围，qing返回  INT_MAX (2<sup>31</sup> − 1) 或 INT_MIN (−2<sup>31</sup>) 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>过滤出字符串中的数字部分，数字包括正负数。注意数字之前只能为空格，否则返回0。超过能表示的最小值或者最大值时返回最小值或最大值。注意要先trim去除前后空格，否则会出现输入<code>&quot; &quot;</code>出错的情况。</p>
<p>再用while循环清除掉空格，默认正数，用symbol表示正负号。遍历每个数字，通过*10+下一位进行字符串转换成int型。注意如果当前数比最大值2147483648 &#x2F; 10 &#x3D; 214748364 更大或者相等时要进行判断，说明将会溢出，这个时候根据参考正负数的类型返回最大值或最小值。</p>
<p>如果没有溢出，最后只要返回转换后的int型就行。</p>
<p>2019.06.20</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">symbol</span> <span class="operator">=</span> <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>)i++;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            symbol = -<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            symbol = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.length() &amp;&amp; str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; Integer.MAX_VALUE / <span class="number">10</span> || (temp == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; str.charAt(i) - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (symbol == <span class="number">1</span>)<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="number">10</span> * temp + (str.charAt(i++) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> symbol * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43 Multiply Strings"></a>43 Multiply Strings</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/multiply-strings/">Multiply Strings</a></p>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<hr>
<p>根据实际中的多位数乘法步骤来，从最后一位起，例如123*456，3和6先进行相乘，得到18，但是这个数存在哪儿呢？根据经验我们可以看到，结果得到的数字长度最多比两数长度和再多1，因此设立末位相乘得到的结果存入索引为2+2+1&#x3D;5的数组中，18存8，进位1，计入索引为4的数组元素中。事实上这一过程就是把过程中得到的数字分别存入数组中，并对元素不断更新相乘。最终得到最后结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length(), n = num2.length();</span><br><span class="line">        <span class="type">int</span>[] process = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> i + j, cur = i + j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> mul + process[cur];</span><br><span class="line"></span><br><span class="line">                process[pre] += sum / <span class="number">10</span>;</span><br><span class="line">                process[cur] = (sum) % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p : process) <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; p == <span class="number">0</span>)) sb.append(p);</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29 Divide Two Integers"></a>29 Divide Two Integers</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/">Divide Two Integers</a><br>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<hr>
<p>本质思路是移位，更通俗一点，设立两个数组。</p>
<p>拿100 -3举例，先把二者全化成正数100和3，两个数组分别是<br> 3, 6,12,24,48,96,192<br> 1, 2, 4, 8,16,32,64<br>索引也分别对应。先减去96，96对应32，即3 * 32 &#x3D; 96，结果中已得到32，但是100-96还有4，4再在第一个数组中找，找到3，对应1，则结果为32+1&#x3D;33。</p>
<p>但这个方法有一点不足的地方是用了long。不用long的可以看这一篇，通过用递归消除用long：<a target="_blank" rel="noopener" href="https://leetcode.wang/leetCode-29-Divide-Two-Integers.html">把正数通通转为求负数</a><br>也可以更好地理解第一个数组的数字设置。</p>
<p>2019.06.23</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">negative</span> <span class="operator">=</span> (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dividendLong</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)dividend); <span class="type">long</span> <span class="variable">divisorLong</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)divisor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((dividendLong &gt;&gt; i) &gt;= divisorLong)&#123;<span class="comment">//找出足够大的数2^n*divisor</span></span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; i; <span class="comment">//将结果加上2^n</span></span><br><span class="line">                dividendLong -= divisorLong &lt;&lt; i;<span class="comment">//将被除数减去2^n*divisor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50 Pow(x, n)"></a>50 Pow(x, n)</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/powx-n/">Pow(x, n)</a></p>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<hr>
<p>递归！看到这种可分解的小问题，就应该要想到递归！主要是用了一点指数的基础公式，把x<sup>n</sup>换成(x<sup>2</sup>)<sup>n&#x2F;2</sup>，同时再考虑到奇偶指数的问题就行了。注意如果指数是负数，把指数调正，x可以变成1&#x2F;x。</p>
<p>2019.06.23</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MIN_VALUE)&#123;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? myPow(x * x, n / <span class="number">2</span>) : x * myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="365-Water-and-Jug-Problem"><a href="#365-Water-and-Jug-Problem" class="headerlink" title="365 Water and Jug Problem"></a>365 Water and Jug Problem</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/water-and-jug-problem/">Water and Jug Problem</a></p>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<hr>
<p>纯粹的数学题。有兴趣可以看这个维基百科：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bézout’s identity</a></p>
<p>两个桶容量分别为xy，要得到z，从描述中可以获得这样一个公式：ax+by&#x3D;z。同时桶可以倒空装满，说明a和b可以是正数也可以是负数。那么接下去要做的就是找到两数的最大公约数，然后看z是不是这个最大公约数的倍数就行了。</p>
<p>具体证明看维基。</p>
<p>2019.06.24</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMeasureWater</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == z || y == z || x + y == z) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> z % greatestCommonDivisor(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">greatestCommonDivisor</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 Tree</h2><h3 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h3><h4 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144 Binary Tree Preorder Traversal"></a>144 Binary Tree Preorder Traversal</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">Binary Tree Preorder Traversal</a></p>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>
<p>2019.06.24</p>
<ul>
<li>解一 递归方法</li>
</ul>
<p>本科算法课基础内容。先序遍历，先根后左子树右子树，用递归的话思路很清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">            pre.add(root.val);</span><br><span class="line">            pre.addAll(preorderTraversal(root.left));</span><br><span class="line">            pre.addAll(preorderTraversal(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二 非递归方法</li>
</ul>
<p>非递归的话就用栈把暂时不用的右子树先存入。优先读取左子树，同时把它对应的每一个右子树存入先进后出的栈中，这样的话，当左子树为空的时候，栈顶就是离它最近的右子树，依次取出即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; rights = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>)rights.push(root.right);</span><br><span class="line">            root = root.left;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; !rights.isEmpty())root = rights.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94 Binary Tree Inorder Traversal"></a>94 Binary Tree Inorder Traversal</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">Binary Tree Inorder Traversal</a></p>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>2019.06.24</p>
<ul>
<li>解一 递归</li>
</ul>
<p>思路清晰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">            inOrder.addAll(inorderTraversal(root.left));</span><br><span class="line">            inOrder.add(root.val);</span><br><span class="line">            inOrder.addAll(inorderTraversal(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二</li>
</ul>
<p>其实和#144的思路差不多，用栈存储左子树，然后一步步往左子树方向走。当走到叶子结点的时候，从栈顶取出左子树的左叶子结点。</p>
<p>判断左节点是否存在且未遍历过，是则进入输出当前节点，出栈。<br>接着判断右节点是否存在且未遍历过，是则进入。如果栈无元素则退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            current = stack.pop();</span><br><span class="line">            inOrder.add(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="104-Binary-Tree-Level-Order-Traversal"><a href="#104-Binary-Tree-Level-Order-Traversal" class="headerlink" title="104 Binary Tree Level Order Traversal"></a>104 Binary Tree Level Order Traversal</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal</a></p>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>2019.06.25</p>
<ul>
<li>解一 DFS</li>
</ul>
<p>通过递归实现深度优先搜索，一层一层加入结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        levelHelper(result, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root, <span class="type">int</span> levelNumber)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (levelNumber &gt;= result.size())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(levelNumber).add(root.val);</span><br><span class="line">        levelHelper(result, root.left, levelNumber + <span class="number">1</span>);</span><br><span class="line">        levelHelper(result, root.right, levelNumber + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二 BFS</li>
</ul>
<p>广度优先搜索，一次性把接下去要遍历的左右子树放入到一个LinkedList中，等稍后分别遍历其左右树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;TreeNode&gt; currentNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        currentNode.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!currentNode.isEmpty())&#123;</span><br><span class="line">            List&lt;TreeNode&gt; nextNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : currentNode)&#123;</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) nextNode.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) nextNode.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯-Backtracking"><a href="#回溯-Backtracking" class="headerlink" title="回溯 Backtracking"></a>回溯 Backtracking</h2><h3 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h3><h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78 Subsets"></a>78 Subsets</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/">Subsets</a></p>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>2019.06.30</p>
<ul>
<li>解一 回溯</li>
</ul>
<p>例如输入1，2，3，4先从1这一层开始，通过递归式，tempList依次添加为[1],[1,2],[1,2,3],[1,2,3,4]，同时分别把不同时期的tempList加入结果集中。再一步步回去并移除最后一位，同时观测i还能不能再进行循环：[1,2,3]不能，[1,2]，i &#x3D; 2，可以进入当前层的循环，添加为[1,2,4]。并继续返回到上一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(result, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtracking(result, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二 迭代</li>
</ul>
<p>继续拿1234举例，遍历1234，将之前的结果暂存到一个列表中，同时将遍历得到的数字插入到之前结果中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">1</span><br><span class="line">2 1,2</span><br><span class="line">3 1,3 2,3 1,2,3</span><br><span class="line">4 1,4 2,4 1,2,4 3,4 1,3,4 2,3,4 1,2,3,4</span><br></pre></td></tr></table></figure>
<p>注意迭代法还可以有另一个思路，这是按照子集元素种类排的，另一个思路可以是按照子集长度排，找出数组长度 1 的所有解，然后再在长度为 1 的所有解上加 1 个数字变成长度为 2 的所有解，同样的直到 n。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; resultTemp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; lastLayer : result)&#123;</span><br><span class="line">                List&lt;Integer&gt; lastLayerTemp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(lastLayer);</span><br><span class="line">                lastLayerTemp.add(nums[i]);</span><br><span class="line">                resultTemp.add(lastLayerTemp);</span><br><span class="line">            &#125;</span><br><span class="line">            result.addAll(resultTemp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解三 位操作思路（StringBuilder实现）</li>
</ul>
<p>所有子集中，数组的每个元素都有两个状态：在或者不在，可以用01表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">0 0 0 -&gt; [     ]</span><br><span class="line">0 0 1 -&gt; [    3]</span><br><span class="line">0 1 0 -&gt; [  2  ]   </span><br><span class="line">0 1 1 -&gt; [  2 3]  </span><br><span class="line">1 0 0 -&gt; [1    ]</span><br><span class="line">1 0 1 -&gt; [1   3] </span><br><span class="line">1 1 0 -&gt; [1 2  ]</span><br><span class="line">1 1 1 -&gt; [1 2 3]</span><br></pre></td></tr></table></figure>
<p>由上图可以很明显地感受到，可以引入二进制进行解题。只需要遍历 0 0 0 到 1 1 1，然后判断每个比特位是否是 1，是 1 的话将对应数字加入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">forTimes</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forTimes; i++ )&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">mirror</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(Integer.toBinaryString(i));</span><br><span class="line">            mirror = mirror.reverse();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mirror.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mirror.charAt(j) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    temp.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解四 位操作</li>
</ul>
<p>其实直接用位操作也可以，思路是一样的，通过移位符直接从最末位看起，但注意这个时候对于输入数组来说，是往后对应的，所以count要++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans_nums</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; nums.length; <span class="comment">//执行 2 的 n 次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans_nums; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录当前对应数组的哪一位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_copy</span> <span class="operator">=</span> i; <span class="comment">//用来移位</span></span><br><span class="line">            <span class="keyword">while</span> (i_copy != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> ((i_copy &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">//判断当前位是否是 1</span></span><br><span class="line">                    tmp.add(nums[count]);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;<span class="comment">//对应数组的应该是往后看</span></span><br><span class="line">                i_copy = i_copy &gt;&gt; <span class="number">1</span>;<span class="comment">//右移一位，从后往前看</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79 Word Search"></a>79 Word Search</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-search/">Word Search</a></p>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],</span><br><span class="line">  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],</span><br><span class="line">  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><p>用回溯法，用深度优先搜索即可，传入该board，当前的横纵坐标和当前字符串进行到的位数。<br>同样还因为传入一个访问数组来判定每个位置是否有被访问。</p>
<p>2021.02.22</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length, cols = board[<span class="number">0</span>].length;</span><br><span class="line">            <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (existRecursive(board, i, j, word, <span class="number">0</span>, visited)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">existRecursive</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col, String word, <span class="type">int</span> index, <span class="type">boolean</span>[][] visited)</span>&#123;</span><br><span class="line">        <span class="comment">//if out of bounds</span></span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[row][col] || board[row][col] != word.charAt(index)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length() - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//Start to determine whether the location can be included</span></span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">up</span> <span class="operator">=</span> existRecursive(board, row - <span class="number">1</span>, col, word, index + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">if</span> (up) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">down</span> <span class="operator">=</span> existRecursive(board, row + <span class="number">1</span>, col, word, index + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">if</span> (down) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> existRecursive(board, row, col - <span class="number">1</span>, word, index + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> existRecursive(board, row, col + <span class="number">1</span>, word, index + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//the current position is not included, reset as unvisited</span></span><br><span class="line">        visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90 Subsets II"></a>90 Subsets II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets-ii/">Subsets II</a></p>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>2019.06.30</p>
<ul>
<li>解一 位操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">forTimes</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forTimes; i++ )&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">mirror</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(Integer.toBinaryString(i)).reverse();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mirror.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mirror.charAt(j) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    temp.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(temp)) &#123;</span><br><span class="line">                result.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二 回溯</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(list, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="type">int</span> [] nums, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="🌟77-Combinations"><a href="#🌟77-Combinations" class="headerlink" title="🌟77 Combinations"></a>🌟77 Combinations</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">Combinations</a></p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>2019.07.01</p>
<ul>
<li>解一 回溯</li>
</ul>
<p>经典回溯，注意总结回溯法的基本框架。这道题非常值得再扩展，有回溯就有迭代，还可以递归，有递归还可以用动态规划，记得补充总结。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>, result, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> starter, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> starter; i &lt;= n; i++)&#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">            backTracking(n, k - <span class="number">1</span>, i + <span class="number">1</span>, result, temp);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39 Combination Sum"></a>39 Combination Sum</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/">Combination Sum</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：所有数字（包括 target）都是正整数；解集不能包含重复的组合。 </p>
<p>2019.07.01</p>
<ul>
<li>解一 回溯<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> starter, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> starter; i &lt; candidates.length; i++)&#123;</span><br><span class="line">                temp.add(candidates[i]);</span><br><span class="line">                backTracking(candidates, target - candidates[i], i, result, temp);</span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40 Combination Sum II"></a>40 Combination Sum II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/">Combination Sum II</a></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：所有数字（包括目标数）都是正整数；解集不能包含重复的组合。 </p>
<p>2019.07.01</p>
<ul>
<li>解一 回溯<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> starter, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> )&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> starter; i &lt; candidates.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; starter &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                temp.add(candidates[i]);</span><br><span class="line">                backTracking(candidates, target - candidates[i], i + <span class="number">1</span>, result, temp);</span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216 Combination Sum III"></a>216 Combination Sum III</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iii/">Combination Sum III</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：所有数字都是正整数；解集不能包含重复的组合。 </p>
<p>2019.07.01</p>
<ul>
<li>解一 回溯</li>
</ul>
<p>拿回溯的结构去套真的好轻松哦…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(k, n, <span class="number">1</span>, result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> starter, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> starter; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">            backTracking(k - <span class="number">1</span>, n - i, i + <span class="number">1</span>, result, temp);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="🌟377-Combination-Sum-IV"><a href="#🌟377-Combination-Sum-IV" class="headerlink" title="🌟377 Combination Sum IV"></a>🌟377 Combination Sum IV</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/">Combination Sum IV</a></p>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>2019.07.01<br>由回溯法发现会超时，想到有没有办法用数组存下中间过程呢。通过动态规划存储过程中结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[i])&#123;</span><br><span class="line">                result += helper(nums, target - nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Permutations</a></p>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>2019.07.02</p>
<ul>
<li>解一 回溯<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> nums[], List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.length) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTracking(nums, temp, result);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47 Permutations II"></a>47 Permutations II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">Permutations II</a><br>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>2019.07.02</p>
<ul>
<li>解一 回溯</li>
</ul>
<p>比起上一题不重复的，主要加入了一个boolean数组判断该数是否已经使用过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.length) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backTracking(result, temp, nums, used);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31 Next Permutation"></a>31 Next Permutation</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">Next Permutation</a></p>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>

<p>2019.07.02</p>
<hr>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="Single Pass Approach"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">theFirstDecreasing</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (theFirstDecreasing &gt;= <span class="number">0</span> &amp;&amp; nums[theFirstDecreasing + <span class="number">1</span>] &lt;= nums[theFirstDecreasing])&#123;</span><br><span class="line">            theFirstDecreasing--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (theFirstDecreasing &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">swapIndex</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (swapIndex &gt;= <span class="number">0</span> &amp;&amp; nums[swapIndex] &lt;= nums[theFirstDecreasing]) swapIndex--;</span><br><span class="line">            swap(nums, theFirstDecreasing, swapIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, theFirstDecreasing + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60 Permutation Sequence"></a>60 Permutation Sequence</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-sequence/">Permutation Sequence</a><br>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br></pre></td></tr></table></figure>
<p>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：给定 n 的范围是 [1, 9]; 给定 k 的范围是[1,  n!]。</p>
<p>2019.07.05</p>
<hr>
<p>拿n &#x3D; 4, k &#x3D; 14举例，把4的结果分为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1（234）</span><br><span class="line">2（134）</span><br><span class="line">3（124）</span><br><span class="line">4（123）</span><br></pre></td></tr></table></figure>
<p>根据4!可知结果一共有24个，按首位不同分为4大类，每类3!为6个。<br>因为从0开始算起，所以14-1&#x3D;13.<br>13&#x2F;6&#x3D;2 余1。因为从0算起，所以2直接对应数组2 1234，为3。确定首位后确定第二位：1&#x2F;2!&#x3D;1&#x2F;2&#x3D;0 余1 所以第二位直接对应数组124第0位，为1。确定第三位：1&#x2F;1!&#x3D;1&#x2F;1&#x3D;1，余0，所以第三位直接对应数组24第1位，为4。剩下2，答案为3142。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] factorial = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            sum *= i;</span><br><span class="line">            factorial[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> k / factorial[n - i];</span><br><span class="line">            result.append(String.valueOf(numbers.get(index)));</span><br><span class="line">            numbers.remove(index);</span><br><span class="line">            k = k - index * factorial[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62 Unique Paths"></a>62 Unique Paths</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">Unique Paths</a><br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>2019.08.08</p>
<ul>
<li>解一：二维动态规划</li>
</ul>
<p>这题其实不难理解，机器人只有向下或者向右移动的可能，所以到达每一格的可能路数这一结果，只有可能由它的上一格和左边格相加得到。</p>
<p>接下去就很简单了，既然是地图格子，就列一个二维数组。将二维数组的边界格子都列为1，因为只有一种可能到达其本身，右边界为一直向右走，只有这一条路，同理下边界。</p>
<p>以m7n3为例，得到初始二维格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 </span><br><span class="line">1 0 0 </span><br><span class="line">1 0 0 </span><br><span class="line">1 0 0 </span><br><span class="line">1 0 0 </span><br><span class="line">1 0 0 </span><br><span class="line">1 0 0 </span><br></pre></td></tr></table></figure>
<p>每一格的结果数只有可能由它的上一格和左边格相加得到，即得到最终地图格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 </span><br><span class="line">1 2 3 </span><br><span class="line">1 3 6 </span><br><span class="line">1 4 10 </span><br><span class="line">1 5 15 </span><br><span class="line">1 6 21 </span><br><span class="line">1 7 28 </span><br></pre></td></tr></table></figure>
<p>因此可以轻松得到一个m7n3范围的地图中，要达到右下角的地点可以有28种走法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                map[i][j] = map[i - <span class="number">1</span>][j] + map[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二：一维数组</li>
</ul>
<p>由解法一还可以再进行化简，我们其实只需要最后一个，所以每次只更新保留最后一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63 Unique Paths II"></a>63 Unique Paths II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>2019.08.24</p>
<hr>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 </span><br><span class="line">0 1 0 </span><br><span class="line">0 0 0 </span><br></pre></td></tr></table></figure>
<p>直接在原图上面改，先把第一行和第一列分别计算出能走的条数，如例中，第一行和第一列都无阻碍，则可以全部记为1，即到每一格只有一条路走。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 </span><br><span class="line">1 1 0 </span><br><span class="line">1 0 0 </span><br></pre></td></tr></table></figure>
<p>最后可以一行行由上方元素和左方元素相加获得，为1的是障碍物，没有路可以到达，因此改为0。最右下角的结果就是到达右下角可走的路的条数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 </span><br><span class="line">1 0 1 </span><br><span class="line">1 1 2 </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> obstacleGrid[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> obstacleGrid[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64 Minimum Path Sum"></a>64 Minimum Path Sum</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p>2021.02.19</p>
<hr>
<p>经过前面几题，应该会写这道DP了，先定边界值，然后每一格的算数和等于该格上的数字+上格或者左格里的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        System.out.println(m+<span class="string">&quot; &quot;</span>+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再简化一下就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) grid[i][j] += grid[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] += grid[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) grid[i][j] += Math.min(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91 Decode Ways"></a>91 Decode Ways</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">Decode Ways</a></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”111” 可以将 “1” 中的每个 “1” 映射为 “A” ，从而得到 “AAA” ，或者可以将 “11” 和 “1”（分别为 “K” 和 “A” ）映射为 “KA” 。注意，”06” 不能映射为 “F” ，因为 “6” 和 “06” 不同。</p>
<p>给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 &#x27;J&#x27; -&gt; &quot;10&quot; 和 &#x27;T&#x27;-&gt; &quot;20&quot; 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串开头的 0 无法指向一个有效的字符。 </span><br></pre></td></tr></table></figure>
<p>2021.04.12</p>
<hr>
<p>无语，这是shopee的笔试题。<br>可以用动态规划解，当想到回溯的那一刻就应该知道可以用动态规划了。建立一个一维数组，dp[i]表示第i位上有多少个解法。<br>一般来说当前位可能是自己本身，也可能和前一位合起来并成表示一个字母，这时候只要考虑dp[i] &#x3D; dp[i - 1]+dp[i - 2]就行。另外防止越界，当i为1时就是2，举例“11”。</p>
<p>除此以外还要考虑特殊字符0，它必须成对出现，如果它前面是1或者2的时候（其实不太可能前面不是1&#x2F;2）要另外考虑，首先它应该是dp[i] &#x3D; dp[i - 2]，然后防止越界，在i &#x3D; 1的时候设置为dp[i] &#x3D; dp[i - 1];</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">1</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) - <span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120 Triangle"></a>120 Triangle</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/">Triangle</a></p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>2019.08.27</p>
<hr>
<p>动态规划思路，自底向上找最短路径。在实际操作中，可以从倒数第二行开始，把这一行上每一个数字都改为当前数字和下一行（倒数第一行）对应的相邻数相加取最小值。以题中数据举例，全部完成后应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 4</span><br><span class="line">7 6 10 </span><br><span class="line">4 1 8 3 </span><br></pre></td></tr></table></figure>
<p>由此依次向上一层递推，得到最终结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11 </span><br><span class="line">9 10 </span><br><span class="line">7 6 10 </span><br><span class="line">4 1 8 3 </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; nextRow = triangle.get(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//和下一行数字相加</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Math.min(nextRow.get(j), nextRow.get(j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">                triangle.get(i).set(j, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279 Perfect Squares"></a>279 Perfect Squares</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/perfect-squares/">Perfect Squares</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>
<p>2019.12.09</p>
<hr>
<p>动态规划思路，自底向上推出通用公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = 0 </span><br><span class="line">dp[1] = dp[0]+1 = 1</span><br><span class="line">dp[2] = dp[1]+1 = 2</span><br><span class="line">dp[3] = dp[2]+1 = 3</span><br><span class="line">dp[4] = Min&#123; dp[4-1*1]+1, dp[4-2*2]+1 &#125; </span><br><span class="line">      = Min&#123; dp[3]+1, dp[0]+1 &#125; </span><br><span class="line">      = 1				</span><br><span class="line">dp[5] = Min&#123; dp[5-1*1]+1, dp[5-2*2]+1 &#125; </span><br><span class="line">      = Min&#123; dp[4]+1, dp[1]+1 &#125; </span><br><span class="line">      = 2</span><br><span class="line">						.</span><br><span class="line">						.</span><br><span class="line">						.</span><br><span class="line">dp[13] = Min&#123; dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 &#125; </span><br><span class="line">       = Min&#123; dp[12]+1, dp[9]+1, dp[4]+1 &#125; </span><br><span class="line">       = 2</span><br><span class="line">						.</span><br><span class="line">						.</span><br><span class="line">						.</span><br><span class="line">dp[n] = Min&#123; dp[n - i*i] + 1 &#125;,  n - i*i &gt;=0 &amp;&amp; i &gt;= 1</span><br></pre></td></tr></table></figure>
<p>对每一个给定的数，比较所有它减去平方数的数，例如13，比较dp[12]、dp[9]、dp[4]，比较它们加上本身被减去的平方数后的最小值即是能组成和的最小平方数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - j * j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                min = Math.min(min, dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139 Word Break"></a>139 Word Break</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/">Word Break</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>2020.02.27</p>
<hr>
<p>根据wordDict依序生成不同字符串，同时与目标字符串进行匹配。如果生成的字符串可以和目标字符串匹配上了但是长度不足，则进入该支线。</p>
<p>如示例3中，首先生成cats，cats和目标字符串全部吻合，则开始深度优先搜索，依序测试catscats和catsdog等，在catsand吻合，进入下一级，catsandcats等等。<br>首先判断长度，长度超出则直接返回false进行同级其他字词匹配；否则逐单词进行比对，如果全部吻合且长度也相等，返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wordBreakHelper(s, wordDict, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Boolean&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">wordBreakHelper</span><span class="params">(String s, List&lt;String&gt; wordDict, String temp, HashMap&lt;String, Boolean&gt; hashMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(temp))&#123;</span><br><span class="line">            <span class="keyword">return</span> hashMap.get(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != temp.charAt(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == temp.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordBreakHelper(s, wordDict, temp + wordDict.get(i), hashMap))&#123;</span><br><span class="line">                hashMap.put(temp, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashMap.put(temp, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="375-Guess-Number-Higher-or-Lower-II"><a href="#375-Guess-Number-Higher-or-Lower-II" class="headerlink" title="375 Guess Number Higher or Lower II"></a>375 Guess Number Higher or Lower II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/">Guess Number Higher or Lower II</a></p>
<p>我们正在玩一个猜数游戏，游戏规则如下：</p>
<p>我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。</p>
<p>每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。</p>
<p>然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 10, 我选择了8.</span><br><span class="line"></span><br><span class="line">第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。</span><br><span class="line">第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。</span><br><span class="line">第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。</span><br><span class="line"></span><br><span class="line">游戏结束。8 就是我选的数字。</span><br><span class="line"></span><br><span class="line">你最终要支付 5 + 7 + 9 = 21 块钱。</span><br></pre></td></tr></table></figure>
<p>给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。</p>
<p>2020.02.29</p>
<hr>
<p>给定一个数字n，对方会从1-n选择什么数字作为最终答案是并不清楚的，同时这个也不重要。题意的要求就是，要算每次都猜错的情况下的总体最小开销。</p>
<p>假设i是第一次选错的数字，那么cost(1, n) &#x3D; i + max( cost(1, i − 1), cost(i + 1, n))。在这一步我们把大问题分解成了小问题。对于左右两段，我们分别考虑在段内选择一个数，并重复上面的过程来求得最小开销。</p>
<p>这一步就是初步暴力的做法，可以得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minres</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> i + Math.max(calculate(i + <span class="number">1</span>, high), calculate(low, i - <span class="number">1</span>));</span><br><span class="line">            minres = Math.min(res, minres);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minres;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这一步超时了。我们想一下是不是可以用数组来存储之前已经算好的结果，这样的话就不需要每次都重复计算。</p>
<p>因为1-n每次都分成不同长度的小段（并不是二分法猜数字耗费最少），所以求1-n之间每次猜错后最终的最小花销，可以细分成求low-high之间每次猜错后最终的最小花销。</p>
<p>例如给出n&#x3D;5，要求出每次都猜错的最小花费，先猜2被告知比2大，再猜4被告知比4大或者小，这样最少需要6可以猜出对方心中想的数字。</p>
<p>要储存不同范围内每次都猜错的最小花费，可以设置一个二维数组，当n&#x3D;5时，这个二维数组dp可以设置为</p>
<table>
<thead>
<tr>
<th align="center">\</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">\</td>
<td align="center">\</td>
<td align="center">\</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">\</td>
<td align="center">\</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">\</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>其中dp[m][n]存储的就是在m-n范围内每次都猜错的最小花费，所以当m &#x3D; n时，dp[m][n] &#x3D; 0;</p>
<p>要规律地填满这个二维数组，先按照范围长度依次递增的顺序进行填充。</p>
<p>例如范围长度为1的时候，依次算1-2，2-3，3-4，4-5<br>很顺利可得二维数组为</p>
<table>
<thead>
<tr>
<th align="center">\</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>当范围长度为2的时候，依次算1-3，2-4，3-5<br>由于之前的1-2，2-3，3-4，4-5已有答案，例如求dp[1][3]时，先1+max(dp[1][0], dp[2][3]) &#x3D; 3;再2+max(dp[1][1], dp[3][3]) &#x3D; 2;得出2最小。<br>依此推论，则很顺利可得二维数组为</p>
<table>
<thead>
<tr>
<th align="center">\</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>自顶向上得出dp[1][n]结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>; start &lt;= n - len; start++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">minRes</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">piv</span> <span class="operator">=</span> start; piv &lt; start + len; piv++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> piv + Math.max(dp[start][piv - <span class="number">1</span>], dp[piv + <span class="number">1</span>][start + len]);</span><br><span class="line">                    minRes = Math.min(res, minRes);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[start][start + len] = minRes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h2><h3 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h3><h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24 Swap Nodes in Pairs"></a>24 Swap Nodes in Pairs</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">Swap Nodes in Pairs</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p>2020.03.25</p>
<hr>
<ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归主要注意三个点：<br>    1. 递归终止条件<br>    2. 递归内部操作<br>    3. 递归返回值</p>
<p>在这个题目里面，假设有head-&gt;next-&gt;next.next点，最终要达到next-&gt;head-&gt;next.next效果，可以确定终止条件是当head或者next为空，同时也可以确定返回值，新链表的head是next，那么返回值就是next，以作为下一个递归的参数。</p>
<p>内部操作也很好懂，把head的下一位链接到next.next，具体这里到底是哪个值其实并不需要在意，只需要连接到第三位就行了，不用细思第三位上到底是什么。这里就可以用递归，swapPairs(next.next)，返回的是第三部分链表结点们的头结点。最后把next的下一位指向head，就完成了链表的转换。记住递归就是不断做重复的操作。</p>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        neg.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> neg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//pre-&gt;1st-&gt;2nd-&gt;2nd.next</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">            pre.next = second;</span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line"></span><br><span class="line">            pre = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归的话就是设置pre-&gt;1st-&gt;2nd三个指针，内部操作完以后再往后顺一位就行了，while循环外要变动的只有两个指针，一个pre一个head，所以只要他俩往后顺一位就行了。neg用来记录头结点。</p>
<h4 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328 Odd Even Linked List"></a>328 Odd Even Linked List</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/odd-even-linked-list/">Odd Even Linked List</a></p>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<p>2020.03.25</p>
<hr>
<p>这题思路很简单，就是拆成两个奇偶链表，因为需要把偶链表的头结点链接到奇链表的尾结点上，双端操作就需要每个链表分别设置头指针和尾指针。</p>
<p>遇到链表题一定要画图，也注意分清楚哪些指针是需要变动的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">oddTail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenTail</span> <span class="operator">=</span> evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (evenTail != <span class="literal">null</span> &amp;&amp; evenTail.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            oddTail.next = evenTail.next;</span><br><span class="line">            oddTail = oddTail.next;</span><br><span class="line">            evenTail.next = oddTail.next;</span><br><span class="line">            evenTail = evenTail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oddTail.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92 Reverse Linked List II"></a>92 Reverse Linked List II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list-ii/">Reverse Linked List II</a></p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>2020.03.26</p>
<hr>
<ul>
<li>迭代</li>
</ul>
<p>不难做，注意遇到链表题要画图画图画图。<br>然后为了防止出现从1开始反转的情况，设置一个neg结点在头指针前。因为要有衔接嘛所以设置一个linkTail作为m结点前一位的结点，linkHead作为m结点本身。只有pre和head两个结点在动（其实为了谨慎一点可以把head设置成为current指针）。pre和head每次往后移一位，进入m-n的范围了，head直接回头指向pre就行了。最后把这段反转链表的头尾衔接上，此时头尾衔接指针应该分别为 linkTail, linkHead; head, head.next。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        neg.next = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">linkTail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">linkHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> neg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">if</span> (count == m)&#123;</span><br><span class="line">                linkTail = pre;</span><br><span class="line">                linkHead = head;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; m &amp;&amp; count &lt; n)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">                head.next = pre;</span><br><span class="line">                pre = head;</span><br><span class="line">                head = temp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == n)&#123;</span><br><span class="line">                linkHead.next = head.next;</span><br><span class="line">                head.next = pre;</span><br><span class="line">                linkTail.next = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> neg.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19 Remove Nth Node From End of List"></a>19 Remove Nth Node From End of List</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List</a></p>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>2020.03.26</p>
<hr>
<p>先遍历一遍得到全长，再通过全长和倒数数字得到顺数的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">overall</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            overall++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> overall - n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        neg.next = head;</span><br><span class="line">        cur = neg;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            target--;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> neg.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题还有一个解法很有意思，但是先不写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">想象一下，两个人进行 100m 赛跑，假设他们的速度相同。开始的时候，第一个人就在第二个人前边 10m ，这样当第一个人跑到终点的时候，第二个人相距第一个人依旧是 10m ，也就是离终点 10m。</span><br><span class="line"></span><br><span class="line">对比于链表，我们设定两个指针，先让第一个指针遍历 n 步，然后再让它俩同时开始遍历，这样的话，当第一个指针到头的时候，第二个指针就离第一个指针有 n 的距离，所以第二个指针的位置就刚好是倒数第 n 个结点。</span><br></pre></td></tr></table></figure>

<h4 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82 Remove Duplicates from Sorted List II"></a>82 Remove Duplicates from Sorted List II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II</a></p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure>
<p>2020.03.28</p>
<hr>
<p>这题画了图以后还是很好做的……设置了三个指针pre cur next，先记录下重复值，一次性消除该重复值的结点们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        neg.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> neg;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> neg.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> neg.next.next;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dupNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == next.val)&#123;</span><br><span class="line">                dupNum = cur.val;</span><br><span class="line">                <span class="keyword">while</span> (next.val == dupNum) &#123;</span><br><span class="line">                    next = next.next;</span><br><span class="line">                    <span class="keyword">if</span>(next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = next;</span><br><span class="line">                cur = next;</span><br><span class="line">                <span class="keyword">if</span>(next != <span class="literal">null</span>)</span><br><span class="line">                    next = next.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span>)&#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2 Add Two Numbers"></a>2 Add Two Numbers</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/">Add Two Numbers</a></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>
<p>2020.03.29</p>
<hr>
<p>这题就用常规思路算就行了，新建一个链表，对l1l2每个相加进位，用个carry。也没什么坑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">num1</span> <span class="operator">=</span> l1, num2 = l2, cur = neg;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num1 != <span class="literal">null</span> || num2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1 != <span class="literal">null</span>) x = num1.val;</span><br><span class="line">            <span class="keyword">if</span> (num2 != <span class="literal">null</span>) y = num2.val;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry + x + y;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (num1 != <span class="literal">null</span>) num1 = num1.next;</span><br><span class="line">            <span class="keyword">if</span> (num2 != <span class="literal">null</span>) num2 = num2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> neg.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h2><h3 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h3><h4 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33 Search in Rotated Sorted Array"></a>33 Search in Rotated Sorted Array</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in Rotated Sorted Array</a></p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p>2020.04.03</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid])&#123;<span class="comment">//左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])&#123;<span class="comment">//target在左边</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right])&#123;<span class="comment">//target在右边</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81 Search in Rotated Sorted Array II"></a>81 Search in Rotated Sorted Array II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">Search in Rotated Sorted Array II</a></p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>2020.04.05</p>
<hr>
<p>注意[1,3,1,1,1]中寻找3这种没办法确定哪边是有序的例子，用left++去掉一个重复元素即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] == nums[mid])&#123;</span><br><span class="line">                left ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153 Find Minimum in Rotated Sorted Array"></a>153 Find Minimum in Rotated Sorted Array</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated Sorted Array</a></p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p>2020.04.06</p>
<hr>
<ul>
<li>解一</li>
</ul>
<p>一个解法是找出轴点，先判断有序，如果左边全是升序，那结点一定存在于右边；如果右边有序，那结点一定存在于左边。</p>
<p>但是这个解法需要考虑边界，一个是[1]的情况，一个是[1,2]的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] &gt; nums[<span class="number">0</span>] || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid])&#123;<span class="comment">//左边有序</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解二</li>
</ul>
<p>另一种解法不需要判断边界值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162 Find Peak Element"></a>162 Find Peak Element</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/">Find Peak Element</a></p>
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure>

<p>2020.04.07</p>
<hr>
<p>找峰值，通过判断升序降序来判断峰值在左边还是右边。while循环条件那边要注意一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid+<span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="*34 Find First and Last Position of Element in Sorted Array"></a>*34 Find First and Last Position of Element in Sorted Array</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></p>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>

<p>2020.04.08</p>
<hr>
<p>两次使用二分查找分别找出左边界和右边界，左边界很好找，当while循环退出，left就是左边界。<br>右边界需要mid每次多+1，保证范围足够大。在两个循环退出后都要判断是否左右边界和target数字相同。是则存入，否则不存。<br>简易版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">if</span> (nums != <span class="literal">null</span> &amp;&amp; nums.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] == target) result[<span class="number">0</span>] = start;</span><br><span class="line">            end = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                mid = start + (end - start) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[end] == target) result[<span class="number">1</span>] = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">extremeInsertionIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> left)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (left &amp;&amp; target == nums[mid])) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] targetRange = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> extremeInsertionIndex(nums, target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert that `leftIdx` is within the array bounds and that `target`</span></span><br><span class="line">        <span class="comment">// is actually in `nums`.</span></span><br><span class="line">        <span class="keyword">if</span> (leftIdx == nums.length || nums[leftIdx] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetRange;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targetRange[<span class="number">0</span>] = leftIdx;</span><br><span class="line">        targetRange[<span class="number">1</span>] = extremeInsertionIndex(nums, target, <span class="literal">false</span>)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题还可以用0.5来求，例如target是8，就在int数组里查找7.5和8.5。这个办法也很绝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">left</span> <span class="operator">=</span> target - <span class="number">0.5</span>, right = target + <span class="number">0.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> bs(nums, left), r = bs(nums, right);</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">double</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= h)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[m]) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> h = m-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="矩阵-Matrix"><a href="#矩阵-Matrix" class="headerlink" title="矩阵 Matrix"></a>矩阵 Matrix</h2><h3 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h3><h4 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48 Rotate Image"></a>48 Rotate Image</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/">Rotate Image</a></p>
<p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2020.04.11</p>
<hr>
<p>矩阵翻转题。观察规律是每四个点旋转，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]</span><br><span class="line">[4,5,6]</span><br><span class="line">[7,8,9]</span><br></pre></td></tr></table></figure>
<p>最先是角上四个点1，3，7，9旋转，最后2，4，8，6旋转。有点难写就换了思路，观察可得先把例中矩阵置换为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 4 7 </span><br><span class="line">2 5 8 </span><br><span class="line">3 6 9 </span><br></pre></td></tr></table></figure>
<p>注意双重循环的条件应该是j &#x3D; i开始。<br>置换完毕后再每行中置换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][n - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54 Spiral Matrix"></a>54 Spiral Matrix</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">Spiral Matrix</a></p>
<p>2020.04.12</p>
<hr>
<p>这题太绝了，我推荐我自己学十遍！主要就是设置边界，如果边界有重合那就说明已经遍历完成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>, down = matrix.length - <span class="number">1</span>, left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) result.add(matrix[up][i]);<span class="comment">//从左移到右</span></span><br><span class="line">            <span class="keyword">if</span> (up++ &gt;= down)<span class="keyword">break</span>; <span class="comment">//重新定义上边界，若上边界大于下边界，则遍历完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> up; i &lt;= down; i++)result.add(matrix[i][right]);<span class="comment">//从上移到下</span></span><br><span class="line">            <span class="keyword">if</span> (right-- &lt;= left) <span class="keyword">break</span>;<span class="comment">//重新定义右边界，若右边界和左边界重合，则遍历完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) result.add(matrix[down][i]);<span class="comment">//从右移到左</span></span><br><span class="line">            <span class="keyword">if</span> (down-- &lt;= up)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> down; i &gt;= up; i--)result.add(matrix[i][left]);</span><br><span class="line">            <span class="keyword">if</span> (left++ &gt;= right)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59 Spiral Matrix II"></a>59 Spiral Matrix II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-ii/">Spiral Matrix II</a></p>
<p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2020.04.13</p>
<hr>
<p>边界值设置这个办法实在是太好用了……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n-<span class="number">1</span>, up = <span class="number">0</span>, down = n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++)&#123;</span><br><span class="line">                result[up][i] = number;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (up++ &gt; down) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> up; i &lt;= down; i++)&#123;</span><br><span class="line">                result[i][right] = number;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right-- &lt; left) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--)&#123;</span><br><span class="line">                result[down][i] = number;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (down-- &lt; up) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> down; i &gt;= up; i--)&#123;</span><br><span class="line">                result[i][left] = number;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left++ &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73 Set Matrix Zeroes"></a>73 Set Matrix Zeroes</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-matrix-zeroes/">Set Matrix Zeroes</a></p>
<p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>2020.04.14</p>
<hr>
<p>第一反应用hashSet！一次AC啦。用HashSet存下0的横竖坐标轴，最后再遍历一次，把记录下的xy轴上的行列都置为0。</p>
<p>但是这个办法要求额外空间，还有另一种办法可以原地置换，就是遇到有0的，把对应的行列第一个值分别记为0，这样在第二次遍历数组的时候，遇到行列第一个值是0的 就可以把整行或者整列清为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; x = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; y = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    x.add(i);y.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (x.contains(i) || y.contains(j))</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378 Kth Smallest Element in a Sorted Matrix"></a>378 Kth Smallest Element in a Sorted Matrix</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">Kth Smallest Element in a Sorted Matrix</a></p>
<p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure>

<p>2020.04.16</p>
<hr>
<ul>
<li>解一 优先队列<br>用优先队列做，正常优先队列是小顶堆，注意要重写比较方法变为大顶堆。如果队列长度大于k，就把最大的poll出去。最终返回堆顶。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                queue.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (queue.size() &gt; k) queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解二 二分查找</li>
</ul>
<p>这题可以通过二分查找做，化作在有序数列中找出一个分界点，使得分界点的左边正好有k个数。当low &gt;&#x3D; high时返回low，就是第k小的元素。<br>两个端点：low是数组最左上角的数字，high是数组最右下角的数字。从数组的每一行开始判断，找出整个数组中少于两极端中端数mid的计数有多少。再根据比较k继续二分查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> matrix[<span class="number">0</span>][<span class="number">0</span>], high = matrix[matrix.length - <span class="number">1</span>][matrix[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &gt; mid) j--;</span><br><span class="line">                count += (j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74 Search a 2D Matrix"></a>74 Search a 2D Matrix</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a></p>
<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>2020.04.17</p>
<hr>
<p>数组的每一行首尾衔接上可以看作有序数列，那么问题可以简化为二分查找在有序数列中找到目标值。low是数组左上角数字的序号，high是数组右下角数字的序号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = matrix[<span class="number">0</span>].length * matrix.length - <span class="number">1</span>;<span class="comment">//0 11</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;<span class="comment">//5</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> mid / matrix[<span class="number">0</span>].length, y = mid % matrix[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240 Search a 2D Matrix II"></a>240 Search a 2D Matrix II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Search a 2D Matrix II</a></p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target &#x3D; 5，返回 true。</p>
<p>给定 target &#x3D; 20，返回 false。</p>
<p>2020.04.18</p>
<hr>
<p>既然是有序，可以用二分，就是先二分查找第一列第一行，都没有的话就递推到第二列第二行，直到最后一行最后一列也被查找过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">shorterDim</span> <span class="operator">=</span> Math.min(matrix.length, matrix[<span class="number">0</span>].length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shorterDim; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">verticalFound</span> <span class="operator">=</span> binarySearch(matrix, target, i, <span class="literal">true</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">horizontalFound</span> <span class="operator">=</span> binarySearch(matrix, target, i, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (verticalFound || horizontalFound)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">boolean</span> vertical)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (vertical)&#123;</span><br><span class="line">            hi = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> hi = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hi &gt;= lo)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (vertical)&#123;<span class="comment">//searching a column</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[start][mid] &lt; target)&#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[start][mid] &gt; target)&#123;</span><br><span class="line">                    hi = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//search a row</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[mid][start] &lt; target)&#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid][start] &gt; target)&#123;</span><br><span class="line">                    hi = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS &amp; BFS"></a>DFS &amp; BFS</h2><h3 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h3><h4 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200 Number of Islands"></a>200 Number of Islands</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a></p>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>2020.04.19</p>
<hr>
<ul>
<li>解一 DFS</li>
</ul>
<p>DFS的解法就是遍历数组，遇到每个1就先转为0再深度搜索，直到把一整块岛屿都转为0。接着进入下一个岛屿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num_islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; rows; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; cols; c++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    num_islands++;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= rows || c &gt;= cols || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解二 BFS<br>和DFS的主要区别是会设立一个队列把所有值为1的位置记录下，然后循环排出这个队列中的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num_islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; rows; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; cols; c++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    num_islands++;</span><br><span class="line">                    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">                    neighbors.add(r * cols + c);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.isEmpty())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> neighbors.remove();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> id / cols;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> id % cols;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                            neighbors.add((row - <span class="number">1</span>)* cols + col);</span><br><span class="line">                            grid[row - <span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; rows &amp;&amp; grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                            neighbors.add((row + <span class="number">1</span>) * cols + col);</span><br><span class="line">                            grid[row + <span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                            neighbors.add(row * cols + col - <span class="number">1</span>);</span><br><span class="line">                            grid[row][col - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; cols &amp;&amp; grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                            neighbors.add(row * cols + col + <span class="number">1</span>);</span><br><span class="line">                            grid[row][col + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解三 并查集</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; rows; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; cols; c++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        uf.union(r * cols + c, (r - <span class="number">1</span>) * cols + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; rows &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        uf.union(r * cols + c, (r + <span class="number">1</span>) * cols + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        uf.union(r * cols + c, r * cols + c - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; cols &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        uf.union(r * cols + c, r * cols + c + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[cols * rows];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="title class_">int</span>[cols * rows];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        parent[i * cols + j] = i * cols + j;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i * cols + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">            <span class="keyword">return</span> parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty)&#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty])&#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty])&#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                    rank[rootx] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130 Surrounded Regions"></a>130 Surrounded Regions</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/surrounded-regions/">Surrounded Regions</a><br>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>2020.06.14</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length, cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) DFS(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][cols - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) DFS(board, i, cols - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cols - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>) DFS(board, <span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (board[rows - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>) DFS(board, rows - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;*&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> rows, <span class="type">int</span> cols)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &lt; <span class="number">0</span> || cols &lt; <span class="number">0</span> || rows &gt; board.length - <span class="number">1</span> || cols &gt; board[<span class="number">0</span>].length - <span class="number">1</span> || board[rows][cols] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[rows][cols] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        DFS(board, rows + <span class="number">1</span>, cols);</span><br><span class="line">        DFS(board, rows - <span class="number">1</span>, cols);</span><br><span class="line">        DFS(board, rows, cols + <span class="number">1</span>);</span><br><span class="line">        DFS(board, rows, cols - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果矩阵是2*2或以下的直接可以返回结果了，因为不存在被包围的元素。<br>从边角找起，找到是<code>O</code>的就应用DFS继续探索，将所有没有被包围的<code>O</code>变为<code>*</code>暂定值。最后遍历这个矩阵，发现还是<code>O</code>的就改为<code>X</code>，发现是<code>*</code>的就改回为<code>O</code>。</p>
<h4 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127 Word Ladder"></a>127 Word Ladder</h4><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder/">Word Ladder</a></p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
<p>2020.12.18</p>
<hr>
<p>这题可用双向bfs想，分别从起始单词和目标单词每次变动一位字母，同时要求变动字母后的单词都在给出的wordlist中。<br>在示例1中，start是hit，end是cog，hit只变动一个字母形成的单词且在wordlist中的有hot。</p>
<table>
<thead>
<tr>
<th align="center">start word</th>
<th align="center">temp</th>
<th align="center">end word</th>
<th align="center">note</th>
<th align="center">step</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hit</td>
<td align="center">hot</td>
<td align="center">cog</td>
<td align="center"></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">cog</td>
<td align="center">[dog,log]</td>
<td align="center">hot</td>
<td align="center">hot更新成为新的word，但start从原来的end开始</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">hot</td>
<td align="center">[dot, lot]</td>
<td align="center">[dog,log]</td>
<td align="center">[dog,log]更新成为新的word，但start从原来的end开始</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">[dog,log]</td>
<td align="center">-&gt;</td>
<td align="center">[dot, lot]</td>
<td align="center">再多一步可以完成变形</td>
<td align="center">5</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; diction = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList), beginSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(), endSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(),</span><br><span class="line">                visitedSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (diction.contains(endWord)) &#123;</span><br><span class="line">            endSet.add(endWord);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">2</span>; !endSet.isEmpty(); step++) &#123;</span><br><span class="line">                Set&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String s : beginSet) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (c != chars[j]) &#123;</span><br><span class="line">                                <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> chars[j];</span><br><span class="line">                                chars[j] = c;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">newS</span> <span class="operator">=</span> String.valueOf(chars);</span><br><span class="line">                                <span class="keyword">if</span> (endSet.contains(newS)) <span class="keyword">return</span> step;</span><br><span class="line">                                <span class="keyword">if</span> (diction.contains(newS) &amp;&amp; visitedSet.add(newS)) temp.add(newS);</span><br><span class="line">                                chars[j] = t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                beginSet = endSet; endSet = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/08/27/leetcode-easy/">
        <span class="nav-arrow">← </span>
        
          LeetCode 简单题汇总（20210401 更新/51）
        
      </a>
    
    
      <a class="nav-right" href="/2019/08/27/INFO5992ReadingMaterials/">
        
          扩展阅读
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="toc-nav-text">数组 Array</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#80-Remove-Duplicates-from-Sorted-Array-II"><span class="toc-nav-text">80 Remove Duplicates from Sorted Array II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#134-Gas-Station"><span class="toc-nav-text">134 Gas Station</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#229-Majority-Element-II"><span class="toc-nav-text">229 Majority Element II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#274-H-Index"><span class="toc-nav-text">274 H-Index</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#275-H-Index-II"><span class="toc-nav-text">275 H-Index II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#220-Contains-Duplicate-III"><span class="toc-nav-text">220 Contains Duplicate III</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#55-Jump-Game"><span class="toc-nav-text">55 Jump Game</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="toc-nav-text">309 Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#11-Container-With-Most-Water"><span class="toc-nav-text">11 Container With Most Water</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-3Sum"><span class="toc-nav-text">15 3Sum</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E7%A4%BA%E4%BE%8B-3%EF%BC%9A"><span class="toc-nav-text">示例 1：12输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：12输入：nums &#x3D; []输出：[]示例 3：12输入：nums &#x3D; [0]输出：[]</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16-3Sum-Closest"><span class="toc-nav-text">16 3Sum Closest</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-nav-text">示例：123输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) </span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-4Sum"><span class="toc-nav-text">18 4Sum</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-nav-text">示例：12345678给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。满足要求的四元组集合为：[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#56-Merge-Intervals"><span class="toc-nav-text">56 Merge Intervals</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#57-Insert-Interval"><span class="toc-nav-text">57 Insert Interval</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#75-Sort-Colors"><span class="toc-nav-text">75 Sort Colors</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#334-Increasing-Triplet-Subsequence"><span class="toc-nav-text">334 Increasing Triplet Subsequence</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#287-Find-the-Duplicate-Number"><span class="toc-nav-text">287 Find the Duplicate Number</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-nav-text">字符串 String</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="toc-nav-text">3 Longest Substring Without Repeating Characters</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#151-Reverse-Words-in-a-String"><span class="toc-nav-text">151 Reverse Words in a String</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#49-Group-Anagrams"><span class="toc-nav-text">49 Group Anagrams</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#179-Largest-Number"><span class="toc-nav-text">179 Largest Number</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-ZigZag-Conversion"><span class="toc-nav-text">6 ZigZag Conversion</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#12-Integer-to-Roman"><span class="toc-nav-text">12 Integer to Roman</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%95%B0%E5%AD%A6-Math"><span class="toc-nav-text">数学 Math</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-2"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#165-Compare-Version-Numbers"><span class="toc-nav-text">165 Compare Version Numbers</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8-String-to-Integer-atoi"><span class="toc-nav-text">8 String to Integer (atoi)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#43-Multiply-Strings"><span class="toc-nav-text">43 Multiply Strings</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#29-Divide-Two-Integers"><span class="toc-nav-text">29 Divide Two Integers</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#50-Pow-x-n"><span class="toc-nav-text">50 Pow(x, n)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#365-Water-and-Jug-Problem"><span class="toc-nav-text">365 Water and Jug Problem</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%A0%91-Tree"><span class="toc-nav-text">树 Tree</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-3"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="toc-nav-text">144 Binary Tree Preorder Traversal</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#94-Binary-Tree-Inorder-Traversal"><span class="toc-nav-text">94 Binary Tree Inorder Traversal</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#104-Binary-Tree-Level-Order-Traversal"><span class="toc-nav-text">104 Binary Tree Level Order Traversal</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9B%9E%E6%BA%AF-Backtracking"><span class="toc-nav-text">回溯 Backtracking</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-4"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#78-Subsets"><span class="toc-nav-text">78 Subsets</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#79-Word-Search"><span class="toc-nav-text">79 Word Search</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-nav-text">示例:1234567891011board &#x3D;[  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]给定 word &#x3D; &quot;ABCCED&quot;, 返回 true给定 word &#x3D; &quot;SEE&quot;, 返回 true给定 word &#x3D; &quot;ABCB&quot;, 返回 false</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#90-Subsets-II"><span class="toc-nav-text">90 Subsets II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%F0%9F%8C%9F77-Combinations"><span class="toc-nav-text">🌟77 Combinations</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#39-Combination-Sum"><span class="toc-nav-text">39 Combination Sum</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#40-Combination-Sum-II"><span class="toc-nav-text">40 Combination Sum II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#216-Combination-Sum-III"><span class="toc-nav-text">216 Combination Sum III</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%F0%9F%8C%9F377-Combination-Sum-IV"><span class="toc-nav-text">🌟377 Combination Sum IV</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#46-Permutations"><span class="toc-nav-text">46 Permutations</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#47-Permutations-II"><span class="toc-nav-text">47 Permutations II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#31-Next-Permutation"><span class="toc-nav-text">31 Next Permutation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#60-Permutation-Sequence"><span class="toc-nav-text">60 Permutation Sequence</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming"><span class="toc-nav-text">动态规划 Dynamic Programming</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%80%E7%BB%B4"><span class="toc-nav-text">一维</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#62-Unique-Paths"><span class="toc-nav-text">62 Unique Paths</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#63-Unique-Paths-II"><span class="toc-nav-text">63 Unique Paths II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#64-Minimum-Path-Sum"><span class="toc-nav-text">64 Minimum Path Sum</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#91-Decode-Ways"><span class="toc-nav-text">91 Decode Ways</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#120-Triangle"><span class="toc-nav-text">120 Triangle</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#279-Perfect-Squares"><span class="toc-nav-text">279 Perfect Squares</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#139-Word-Break"><span class="toc-nav-text">139 Word Break</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#375-Guess-Number-Higher-or-Lower-II"><span class="toc-nav-text">375 Guess Number Higher or Lower II</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%93%BE%E8%A1%A8-Linked-List"><span class="toc-nav-text">链表 Linked List</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-5"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#24-Swap-Nodes-in-Pairs"><span class="toc-nav-text">24 Swap Nodes in Pairs</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#328-Odd-Even-Linked-List"><span class="toc-nav-text">328 Odd Even Linked List</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#92-Reverse-Linked-List-II"><span class="toc-nav-text">92 Reverse Linked List II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="toc-nav-text">19 Remove Nth Node From End of List</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#82-Remove-Duplicates-from-Sorted-List-II"><span class="toc-nav-text">82 Remove Duplicates from Sorted List II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-Add-Two-Numbers"><span class="toc-nav-text">2 Add Two Numbers</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search"><span class="toc-nav-text">二分查找 Binary Search</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-6"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="toc-nav-text">33 Search in Rotated Sorted Array</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#81-Search-in-Rotated-Sorted-Array-II"><span class="toc-nav-text">81 Search in Rotated Sorted Array II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="toc-nav-text">153 Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#162-Find-Peak-Element"><span class="toc-nav-text">162 Find Peak Element</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="toc-nav-text">*34 Find First and Last Position of Element in Sorted Array</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%9F%A9%E9%98%B5-Matrix"><span class="toc-nav-text">矩阵 Matrix</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-7"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#48-Rotate-Image"><span class="toc-nav-text">48 Rotate Image</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#54-Spiral-Matrix"><span class="toc-nav-text">54 Spiral Matrix</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#59-Spiral-Matrix-II"><span class="toc-nav-text">59 Spiral Matrix II</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#73-Set-Matrix-Zeroes"><span class="toc-nav-text">73 Set Matrix Zeroes</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="toc-nav-text">378 Kth Smallest Element in a Sorted Matrix</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#74-Search-a-2D-Matrix"><span class="toc-nav-text">74 Search a 2D Matrix</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#240-Search-a-2D-Matrix-II"><span class="toc-nav-text">240 Search a 2D Matrix II</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#DFS-BFS"><span class="toc-nav-text">DFS &amp; BFS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80-8"><span class="toc-nav-text">基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#200-Number-of-Islands"><span class="toc-nav-text">200 Number of Islands</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#130-Surrounded-Regions"><span class="toc-nav-text">130 Surrounded Regions</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#127-Word-Ladder"><span class="toc-nav-text">127 Word Ladder</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/08/27/leetcode-medium/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>